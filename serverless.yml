# CogniCity Sensors Endpoint
service: cognicity-sensors

custom:
  projectName: cognicity-sensors

# AWS parameters
provider:
  name: aws
  runtime: nodejs6.10
  stage: dev
  region: ${file(./.env.yml):region}
  stackTags:
    area: ${file(./.env.yml):area_tag}
  vpc:
    securityGroupIds:
      - ${file(./.env.yml):securityGroupIds}
    subnetIds:
      - ${file(./.env.yml):subnetIdA}
      - ${file(./.env.yml):subnetIdB}

# Add one function for each Lambda
# TODO - rate limits
# TODO - caching
functions:
  getSensors: # Lambda that gets sensors
    timeout: ${file(./.env.yml):timeout}
    environment:
        PGHOST: ${file(./.env.yml):PGHOST}
        PGDATABASE: ${file(./.env.yml):PGDATABASE}
        PGPASSWORD: ${file(./.env.yml):PGPASSWORD}
        PGPORT: ${file(./.env.yml):PGPORT}
        PGSSL: ${file(./.env.yml):PGSSL}
        PGTIMEOUT: ${file(./.env.yml):PGTIMEOUT}
        PGUSER: ${file(./.env.yml):PGUSER}
    handler: bin/functions/getSensors.default
    events:
      - http:
          path: sensors
          method: GET # This webhook lambda is called by twitter to verify the bot
          integration: lambda
          parameters:
            querystrings:
              bbox: false # optional
              format: false # optional
  getSensorData: # Lambda that gets sensor data
    timeout: ${file(./.env.yml):timeout}
    environment:
        PGHOST: ${file(./.env.yml):PGHOST}
        PGDATABASE: ${file(./.env.yml):PGDATABASE}
        PGPASSWORD: ${file(./.env.yml):PGPASSWORD}
        PGPORT: ${file(./.env.yml):PGPORT}
        PGSSL: ${file(./.env.yml):PGSSL}
        PGTIMEOUT: ${file(./.env.yml):PGTIMEOUT}
        PGUSER: ${file(./.env.yml):PGUSER}
    handler: bin/functions/getSensorData.default
    events:
      - http:
          path: sensors/{id}
          method: GET # This webhook lambda is called by twitter to verify the bot
          integration: lambda
          parameters:
            paths:
              id: true
    addSensor: # Lambda that posts sensor metadata
      timeout: ${file(./.env.yml):timeout}
      environment:
          PGHOST: ${file(./.env.yml):PGHOST}
          PGDATABASE: ${file(./.env.yml):PGDATABASE}
          PGPASSWORD: ${file(./.env.yml):PGPASSWORD}
          PGPORT: ${file(./.env.yml):PGPORT}
          PGSSL: ${file(./.env.yml):PGSSL}
          PGTIMEOUT: ${file(./.env.yml):PGTIMEOUT}
          PGUSER: ${file(./.env.yml):PGUSER}
      handler: bin/functions/addSensor.default
      events:
        - http:
            path: sensors/
            method: POST # This webhook lambda is called by twitter to verify the bot
            integration: lambda
  addSensorData: # Lambda that gets sensor data
    timeout: ${file(./.env.yml):timeout}
    environment:
        PGHOST: ${file(./.env.yml):PGHOST}
        PGDATABASE: ${file(./.env.yml):PGDATABASE}
        PGPASSWORD: ${file(./.env.yml):PGPASSWORD}
        PGPORT: ${file(./.env.yml):PGPORT}
        PGSSL: ${file(./.env.yml):PGSSL}
        PGTIMEOUT: ${file(./.env.yml):PGTIMEOUT}
        PGUSER: ${file(./.env.yml):PGUSER}
    handler: bin/functions/addSensorData.default
    events:
      - http:
          path: sensors/{id}
          method: POST # This webhook lambda is called by twitter to verify the bot
          integration: lambda
          parameters:
            paths:
              id: true
